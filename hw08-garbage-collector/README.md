## Домашнее задание 8

### Определение нужного размера хипа

Цель:
: На примере простого приложения понять какое влияние оказывают сборщики мусора.

Описание/Пошаговая инструкция выполнения домашнего задания:
: 

- Есть готовое приложение (модуль homework)

- Запустите его с размером хипа 256 Мб и посмотрите в логе время выполнения.

- Пример вывода: spend msec:18284, sec:18

- Увеличьте размер хипа до 2Гб, замерьте время выполнения.

- Запуски записывайте в таблицу.

- Определите оптимальный размер хипа, т.е. размер, превышение которого,
  не приводит к сокращению времени выполнения приложения.

- Оптимизируйте работу приложения.

- Т.е. не меняя логики работы (но изменяя код), сделайте так, чтобы приложение работало быстро с минимальным хипом.

- Повторите измерения времени выполнения программы для тех же значений размера хипа.

### Измерения до оптимизации приложения

Судя по результатам запусков с разными размерами хипа, рост производительности остановился между 896m и 1024m.

То есть в данном случае 1024m будет оптимальным решением.

| Xms/Xmx | Результат              |
|:-------:|:-----------------------|
|  256m   | spend msec:9806, sec:9 |
|  512m   | spend msec:7301, sec:7 |
|  768m   | spend msec:7151, sec:7 |
|  896m   | spend msec:6957, sec:6 |
|  1024m  | spend msec:6863, sec:6 |
|  1280m  | spend msec:6877, sec:6 |
|  1536m  | spend msec:6869, sec:6 |
|  2048m  | spend msec:6884, sec:6 |
|  4096m  | spend msec:6876, sec:6 |

### Оптимизация приложения

1. Примерно в 3 раза быстрее начинает работать приложение после избавления от массива `List<Data> listValues`. Нам не
   нужно хранить все
   объекты. Памяти больше не нужно так много.
   После оптимизации результат с размером хипа `1024m` был следующий spend `msec:3127, sec:3`.
2. Ещё примерно в 7 раз быстрее начинает работать приложения после перехода к примитивам, где это возможно, без
   изменения сигнатур методов.
   После только этой оптимизации результат с размером хипа `1024m` был следующий spend `msec:986, sec:0`.
3. После обоих оптимизаций результат с размером хипа `1024m` был следующий spend `msec:294, sec:0`.
4. Теперь поэкспериментируем с размером хипа вновь после оптимизаций кода с теми вариантами размера хипа.

| Xms/Xmx | Результат             |
|:-------:|:----------------------|
|   4m    | spend msec:331, sec:0 |
|   8m    | spend msec:303, sec:0 |
|   16m   | spend msec:301, sec:0 |
|   32m   | spend msec:298, sec:0 |
|   64m   | spend msec:294, sec:0 |
|  256m   | spend msec:293, sec:0 |
|  512m   | spend msec:295, sec:0 |
|  1024m  | spend msec:295, sec:0 |
|  4096m  | spend msec:295, sec:0 |

Большой хип нам больше не нужен. До `256m` gc в лог ничего не пишет кроме трех строк инициализации.
При уменьшении от `256m` включительно до `8m` появляются записи о паузах области с молодым поколением:
> GC(1) Pause Young (Normal) (G1 Evacuation Pause) 2M->1M(8M) 0.127ms

При `256m` стабильно одна строка с Pause Young. А чем хип меньше, тем записей заметно больше. Но паузы очень
короткие до 1ms. Так что не сильно влияют на время работы.

При `4m` пояаляются более долгие паузы:
> GC(41) Pause Full (G1 Compaction Pause) 1M->1M(4M) 1.815ms

При `2m` приложение падает с ошибкой `java.lang.OutOfMemoryError: Java heap space`)

### Вывод

Как на уроке сказали, оптимизация кода намного важнее.
Для оптимизированного приложения можно выбрать любой размер от `8m`, но если хотим совсем без пауз gc, то `512m`
хипа уже достаточно.
